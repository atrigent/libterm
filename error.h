#ifndef ERROR_H
#define ERROR_H

/* Error reporting policy in libterm:
 * If a system call that libterm calls returns an error, there are currently three
 * means in which these errors are communicated to the program using libterm:
 *
 * 1. Use FIXABLE_SYS_ERR to set curerr, leave errno alone, and return -1
 *      This is used when an error is returned by a system call which libterm
 *      uses, but the application using libterm could be at fault. This way it
 *      seems as if the error was actually generated by the libterm function,
 *      not the underlying system call. In this case, the documentation for the
 *      libterm function will describe the meaning of each errno value. In
 *      addition, curerr will be set appropriately for more detailed information
 *      on where the error occured.
 * 2. Use FIXABLE_LTM_ERR to set curerr.sys_func to NULL, set errno and
 *    curerr.err_no, set curerr.ltm_func to __func__, and return -1
 *      This is used for errors which really originate from a libterm function
 *      instead of a system call which a libterm function calls. This would look
 *      exactly the same as error method #1 except that curerr.sys_func is set
 *      to NULL because there's really no more information to be given.
 * 3. Use FATAL_ERR to set curerr, set errno to 0, and return -1
 *      This would be mainly for weird errors not seen very often. The
 *      application should not try to fix errors reported using this method. The
 *      libterm function returns -1 and sets errno to zero so that the
 *      application would be able to tell this type of error apart from a
 *      normal error.
 *
 *      Here's roughly what a libterm function call should look like (if it
 *      returns errors):
 *
 *      if(ltm_j_random_libterm_function(blorgh, zblat) == -1) {
 *           if(!errno) {
 *                // oops! fatal error! red alert! close program ASAP!!!
 *           }
 *           else if(!curerr.sys_func) {
 *                // fixable libterm error. use yer own error reporting
 *                // thingee or try to fix it!!!
 *           }
 *           else {
 *                // fixable system error. usually the only option here
 *                // is to use your own error reporting mechanism, because
 *                // there are too damn many to try to fix all of them...
 *                // (do try to fix some though!!!)
 *           }
 *      }
 *
 *      Luckily, you won't have to call very many libterm functions yourself,
 *      so you don't have to partake in this elaborate ritual too often...
 */

/* taken from http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Function-Names.html */
#if __STDC_VERSION__ < 199901L
# if __GNUC__ >= 2
#  define __func__ __FUNCTION__
# else
#  define __func__ "<unknown>"
# endif
#endif

/* program should try to resolve or report the error
 * used for system call errors
 */
#define FIXABLE_SYS_ERR(name, data) \
	do { \
		curerr = {name, __func__, data, errno}; \
		if(always_dump) error_info_dump(curerr, LTM_TRUE); \
		return -1; \
	} while(0);

/* program should try to resolve or report the error
 * used for errors set by a libterm function
 */
#define FIXABLE_LTM_ERR(err) \
	do { \
		curerr = {NULL, __func__, NULL, err}; \
		if(always_dump) error_info_dump(curerr, LTM_TRUE); \
		errno = err; \
		return -1; \
	} while(0);

/* program should not try to resolve or report the error
 * used for system call errors
 */
#define FATAL_ERR(name, data) \
	do { \
		curerr = {name, __func__, data, errno}; \
		error_info_dump(curerr, LTM_FALSE); \
		errno = 0; \
		return -1; \
	} while(0);

struct error_info {
	char * sys_func;
	char * ltm_func;
	char * data;
	int err_no;
};

extern struct error_info curerr;
extern int always_dump;

#endif
